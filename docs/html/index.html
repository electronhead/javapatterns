<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en"><html><head>      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">      <meta name="Author" content="Gary Beaver">      <meta name="GENERATOR" content="Mozilla/4.61 [en] (WinNT; U) [Netscape]">      <meta name="Classification" content="programming language, internet">      <meta name="Description" content="A dynamic dispatch mechanism for Java under development at ElectronHead.">      <meta name="KeyWords" content="java, dynamic dispatch">  <title>Java Patterns</title>  <meta name="author" content="Gary Beaver">  <meta name="description" content="home page for javapatterns sourceforge.net project"></head>  <body>    <div align="Right"> <hr width="100%"></div>  <div align="Right"><i><font color="#800000"><font size="+2">Java PatternLookup</font></font></i>&nbsp; <hr width="100%"></div>  <h2> <font color="#000080"><font size="+2">Introduction</font></font></h2> This page introduces the Java Pattern Lookup library (JPLL), a collectionof classes and interfaces that enables Java programs to dynamically access[in-memory] data and invoke methods using rule-based data patterns.You definethese data patterns in terms of the classes and objects of your application.Dynamic access is provided without any pre- or post-processing of sourceor class files. <p>Inspirations for JPLL include the multi-method dispatch policies of the Common Lisp Object System (CLOS) and the Lisp derivative, Dylan. If you arefamiliar with either CLOS, Dylan, or any other language that supports run-timemethod resolution based on the actual (vs. formal) types of all (vs. some)parameters, then you will already be somewhat familiar with the conceptspresented here. For Java programmers, the corresponding analog would be ifthe part of method dispatch policy involving run-time types were extendedto include all objects in the method's parameter list instead of just therun-time type of the receiving object. </p><p>JPLL implements the dynamic selection policies of the above-mentioned languagesand extends them by using logical implication instead of type-resolution. Logical implication provides more flexibility when defining patterns. Furthermore,&nbsp;JPLL's implementation of logical implication enables the developer to define additional types of rules that participate in logical implication. </p><p>When you are creating software that must in some way dynamically react to patterns of information, JPLL can provide the means to organize and execute your application's responses. <br>&nbsp; </p>   <h2> <font color="#000066">Main JPLL Classes</font></h2> The fundamental class of the library is PatternDAG, from which the mainclasses in JPLL derive as follows: <p><tt>java.lang.Object</tt> </p><ul>  <tt>org.toadcode.pattern.core.PatternDAG<br>  </tt></ul><blockquote>  <blockquote><tt>org.toadcode.pattern.core.</tt><tt>PatternTree</tt><br>    </blockquote>    </blockquote>      <ul>       <ul>         <ul>          <tt>org.toadcode.pattern.core.PatternDispatcher</tt>        </ul>       </ul>     </ul>        <h2> <font color="#000066">A Starting Point</font></h2> To get an idea of how a PatternDAG works, consider the familiar data structure implemented in the Java class, <tt>java.util.Hashtable</tt>. Hashtables letyou store and access an object, the <i>value</i>, based on the value of anotherobject, the <i>key</i>. To associate a key object, <tt>k</tt>, with a valueobject, <tt>v</tt>, using the Hashtable, <tt>h</tt>, you apply <tt>Hashtable</tt>'s put method as follows:&nbsp; <tt>h.put (k, v)</tt>. To access the value associated with <tt>k</tt>, you apply the get method as follows: <tt>h.get (k)</tt>.     <p><tt>K k = new K();</tt> <br>    <tt>V v = new V();</tt> <br>    <tt>Hashtable h = new Hashtable();</tt> <br>    <tt>h.put(k,v);</tt> <br>    <tt>V v2 = (V)h.get(k);</tt> <br>    <tt>v == v2 // returns true</tt> </p>    <p>Now suppose that you require more flexibility in specifying the keypart of the Hashtable. Let's say that you need to retrieve V, except thatyou would rather base the value lookup on the class of the key instead ofthe key itself -- similar to how methods are selected polymorphically forexecution in Java and in other languages. Hashtables would not fit the bill;    <tt>h.put (K.class, v)</tt> would not result in the desired access using    <tt>k</tt> or other instances of <tt>K</tt> as keys later on. </p>    <p>To achieve this sort of functionality, one can use a PatternTree,a sub-class of PatternDAG. The following code illustrates the point: </p>    <p><tt>PatternTree pt = new PatternTree (new RuleProxy[]{XT.x});</tt> <br>    <tt>pt.put (new Rule[]{XT.<u>of</u>(K.class)},v);</tt> <br>    <tt>V v2 = (V)pt.get(new Object[]{k});</tt> <br>    <tt>K k2 = new K();</tt> <br>    <tt>V v3 = (V)pt.get(new Object[]{k2});</tt> </p>    <p><tt>v == v2 // returns true</tt> <br>    <tt>v2 == v3 // returns true</tt> </p>    <p>The first line creates a PatternTree using an array of RuleProxy objects. The RuleProxy object tells the PatternTree what type of rule can and will be used in the RuleProxy's position in a pattern. In this case, the first and only element of a pattern can be a rule that corresponds to the XT typeof rule. <b>[In general, a pattern is defined using an array of rules.]</b> </p>    <p>The next line of code associates a pattern represented by an arraywith one rule in it, namely, <tt>XT.of (K.class)</tt>, with a value. Taking the method name, <tt>of</tt>, as a clue, this rule returns true if the correspondingobject in a supplied pattern is an instance of <tt>K</tt>. <b>[In general,a rule takes a value and returns either <tt>true</tt> or <tt>false.]</tt></b> </p>    <p>The next line of code selects the value in <tt>pt</tt> corresponding to the pattern, <tt>new Object [] {k}</tt>. Since <tt>k</tt> is an instance of <tt>K</tt>, the value returned, as in the case of the following lines, is <tt>v</tt>. </p>    <p>Let's now say that you need also to select values based on key equality (as in the Hashtable example) in addition to selection based on class membership. In terms of the above example, the following code illustrates how to select     <tt>v4</tt> based on <tt>k3</tt>, a particular instance of <tt>K</tt>, and select <tt>v</tt> for other all other instances of <tt>K</tt>. </p>    <p><tt>K k3 = new K();</tt> <br>    <tt>V v4 = new V();</tt> <br>    <tt>pt.put (new Rule[]{XT.<u>is</u>(k3)},v4);</tt> </p>    <p><tt>v == (V)pt.get(new Object[]{k}) // returns true</tt> <br>    <tt>v == (V)pt.get(new Object[]{new K()}) // returns true</tt> <br>    <tt>v4 == (V)pt.get(new Object[]{k3}) // returns true</tt> </p>    <p>Why did <tt>pt.get(...)</tt> return <tt>v4</tt> in the last line above?     </p>    <p>Before answering, first note that because XT.x is the RuleProxy ofinterest, JPLL views the pattern defined by <tt>new Object [] {k}</tt> asa short-hand equivalent to the pattern defined by <tt>new Rule [] {XT.is(k)}</tt>. JPL actually deals with rules and not values; values are transformedinto their corresponding RuleProxy's <i>instance rule</i>. </p>    <p>As you may recall from the introduction, pattern matching uses logical implication among rules to determine which value to select. <b>[A rule M&nbsp;implies another rule N if and only if for every value of v where M(v) ==true, then N(v) == true.]</b> </p>    <p>From the example we have two possible candidates: the rule involving the "of" method and the rule involving the "is" method. In general, <b>JPLL will pick the least general rule among all rules in the PatternTree which are implied by the incoming pattern</b>. The least general rule for a pattern is the rule that [1] is implied by the supplied pattern's equivalent rule and [2] is not implied by any other rule in the PatternTree (and hence least).     </p>    <p>So because [a] <tt>k3</tt>'s corresponding instance rule is <tt>XT.is(k3)</tt>, [b] any rule implies itself, and [c] <tt>XT.of(K.class)</tt> does not imply     <tt>XT.is(k3)</tt>, the result is <tt>v4</tt> and not <tt>v</tt>. </p>    <p>The above PatternTree uses a rule list of length one, just as there is one key element used in looking up Hashtable values. But more likely thannot, you will define PatternDAGs using rules lists of length greater thanone. In addition, you will define rules involving the Java class/sub-class hierarchy and choose from different rule types.<br>    </p>    <p> </p>    <center></center>      </body>    </html>